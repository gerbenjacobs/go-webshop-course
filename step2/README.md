# Step 2: Let's add Products

In this step we're going to create a handler, service and storage for __Products__.


## Domain models

Within our system we're going to have to pass data around, we'll put these in _domain models_.

If we take a `User` for example, we can think of it as:

```go
type User struct {
	ID       int
	Username string
	Password string
	Email    string
	IsActive bool
}
```

But our frontend is sending us formdata, or JSON or maybe even GRPC:

```go
type UserCreationRequest struct {
	Username         string `json:"user"`
	Password         string `json:"password"`
	RepeatedPassword string `json:"password_again"`
	Email            string `json:"email"`
}
```

There is no `ID` and we have a double `Password` field. The former will be generated by our storage layer,
while the latter we will have to check in our service (as business logic): `if ucr.Password != ucr.RepeatedPassword`.

Finally our storage struct might look like this:

```go
type UserDAO struct {
	ID             uint64
	Username       string
	SaltedPassword string
	Email          *string      // Pointer string allows us to have null-values for Email
	ActivatedAt    sql.NullTime // Uses sql.NullTime for nullable time fields
	CreatedAt      time.Time    // Automatically managed by GORM for creation time
	UpdatedAt      time.Time    // Automatically managed by GORM for update time
}
```

We are now storing an encrypted password, we have an ActivatedAt field and we have created and updated fields,
that in this case will be automatically updated by our fictious database client.

### Domain model as the transport

Regardless of all these differences, our handler, service and storage layer have to talk in _domain models_ and
use our `User` struct. This means that we need to _translate_ from one to the other.

Our model doesn't know about `RepeatedPassword` because this is an UI validation we have. Our model also doesn't
know about encrypting/salting passwords, as this is done within our storage layer.

This is good though, this means we can independently improve our system in phases and even replace entire databases, 
if we wish.

It's very normal to have translation helpers for these internal structs.

```go
func UserToDAO(u User) UserDAO {
	securePassword := encryptPassword(u.Password)
	return UserDAO{
		ID:             uint64(u.ID),
		Username:       u.Username,
		SaltedPassword: securePassword,
		Email:          &u.Email,
	}
}

func DAOToUser(d UserDAO) User {
	var email = ""
	if d.Email != nil {
		email = *d.Email
	}
	var isActive = false
	if d.ActivatedAt.Valid && d.ActivatedAt.Time.Before(time.Now()) {
		isActive = true
	}
	return User{
		ID:       int(d.ID),
		Username: d.Username,
		// Password: password will not be sent
		Email:    email,
		IsActive: isActive,
	}
}
```

Here we deal with integer conversions, omitted data, nil-values and possibly more.

Now let's create our own first domain model!

### product.go

Yep, no folders, we will put this one straight into the root of our project.

This is going to be our domain model for a __Product__.

```go
package go_webshop_course

type Product struct {
	ID          int
	Name        string
	Description string
	Image       string
	Price       float64
}
```

Floating point numbers aren't great to represent money, but hey, this is just a course!

## Interfaces

We will use interfaces a lot in the svc framework, this allows us to make contracts with components,
but also easily test our code.

As part of the guidelines, the self-titled files in `services` and `storage` contain the interfaces
that we use.

Let's start creating our interfaces, beginning with the service.

### service/service.go

So what we want to start with is basically listing our products on the homepage of our webshop.

```go
package services

import (
	"context"

	app "github.com/gerbenjacobs/go-webshop-course"
)

type ProductService interface {
	ListProducts(context.Context) ([]app.Product, error)
}
```

We have a `ListProducts` call, we give it a context ([learn why](https://www.bytesizego.com/blog/context-should-be-first-go))
and it returns us a list of Products and a possible error.

We don't know about _categories_ and our frontend doesn't support _sorting_, yet. More than likely we're gonna have to come
back to this interface and change it, so that our Product Service can handle better calls.

We're giving our package import an alias of `app`, so we can clearly see we're dealing with our domain models.
(_Also in this case it's way cleaner than the original package name of `go_webshop_course`._)

### storage/storage.go

Time to create interfaces for our storage layer. We know we want to list products, let's make something similar. 

```go
package storage

import (
	"context"

	app "github.com/gerbenjacobs/go-webshop-course"
)

type ProductRepository interface {
	GetAllProducts(context.Context) ([]app.Product, error)
}
```

Well that looks familiar, doesn't it? Apart from the naming, we have the same arguments and return values.

In the same vein that we might update our service interface, we might update this one too later.
But there's a bigger chance that we keep this method for admin purposes (i.e. export all our products in JSON)

That means after we have categories and sorting, we could have this:

```go
type ProductRepository interface {
	GetAllProducts(context.Context) ([]app.Product, error)
	GetProductsByCategory(context.Context, app.Category, app.Sortby) ([]app.Product, error)
}
```

Or even like this:
```go
type ProductRepository interface {
	GetAllProducts(context.Context) ([]app.Product, error)
	GetProductsByCategory(context.Context, app.Category, app.Sortby) ([]app.Product, error)
	GetProductsSorted(context.Context, app.Sortby) ([]app.Product, error)
}
```

This can depend on how we deal with categories. Are we storing category in a column of our `products` table,
or is there a pivot-table. Will this `JOIN` make our call slow? Do we want to sort by `ORDER BY`,
or does our _NoSQL_ database not have native support for sorting? Should we let the frontend and Javascript do it?

## Implementations

Time to start implenting. This time we switch the order, let's work on our 'database'.

How about, for now, we just make an in-memory database. We will only have a few products anyway,
and are not even ready for production data.

And by 'in-memory database' I mean just `map[int]Product` ;)

### storage/product_repository_memory.go

```go
package storage

import app "github.com/gerbenjacobs/go-webshop-course"

type ProductRepo struct {
	products map[int]app.Product
}
```

In your editor make it so this struct implements the interface from our storage layer. Make sure to use pointer receivers i.e. `p *ProductRepo`.

In VSCode you can do `CMD + SHIFT + P` to open the command pallette and search for 'interface'. You'll find "Go: Generate Interface Stubs",
use that and enter `p *ProductRepo ProductRepository` (format is `<receiver> <interface name>`). _(You have to download a library to get this to work)_

In IntelliJ you can right-click the struct and pick `Generate ..`, then pick "Interface" and search for `ProductRepository`.

__Task__: Now that you have a method for `GetAllProducts`, you'll have to implement it. It expects to return a slice, but we have a map.
This means we have to create a local variable and range over the map to populate it. Then we can return the slice and `nil` for the error value.

If you're stuck, you can have a peek at `storage/product_repository_memory.go`.

### services/product.go

We can now create our service. If you think back to our layers, and their order, you know it's: `handler -> service -> storage`.

So while storage didn't need much yet, our service relies on the interface from our storage layer, namely: `ProductRepository` interface.

```go
package services

import "github.com/gerbenjacobs/go-webshop-course/storage"

type ProductSvc struct {
	repo storage.ProductRepository
}

func NewProductService(repo storage.ProductRepository) *ProductSvc {
	return &ProductSvc{repo: repo}
}
```

So we create a `ProductSvc` (notice how we can't call it `ProductService` as this name is already taken by our interface),
that has to have a copy of a `storage.ProductRepository`.

Again, implement the missing interface. This time the body will be simple: `return p.repo.GetAllProducts(ctx)`

As you can see we also have a non-receiver method, prefixed with 'New'. Pretty much every time your struct requires something
during initialization, the idiomatic Go way is to create a constructor.

In general we __request__ interfaces, but __return__ implementations. We often return them as pointers, because everything
is passed by value in Go. And thus sending a pointer to an address is much smaller than your entire struct in memory.

You'd think we could just call it `New()`, but you have to keep in mind how the code will look if it's called somewhere else.
Because we'll have multiple services in our `services` package, they can't all be called `services.New()`.

## Tying it together

Alright, we've tackled `storage`, we've tackled `services`, now it's time to tie these all together in our handler.

### Introducing dependencies

In our `handler/handler.go` we're going to create a `Dependencies` struct that requires a `ProductService` interface.

```go
type Dependencies struct {
	Product services.ProductService
}
```

It wants interfaces, but we'll give it actual implementations. We'll do this from our `main.go`, so that's why 
we capitalize the attributes i.e. 'Product' so they are public and accessible from main.

__Task__: Add this `Dependencies` struct to the `Handler` struct and update `handler.New()` to now, 
after the logger, also accept these Dependencies.

### Time to update main.go

We now have to go back to `cmd/app/main.go` and make sure we get `handler.New()` to work again.

Let's work backwards:

- our `handler.New` now requires `Dependencies`, create a local variable
- our Dependencies has a `Product` that needs to be filled, create a local variable
- our `services.NewProductService()` needs to be initialized with a `storage.ProductRepository`, yep, again a local variable
- our `storage.ProductRepo` needs nothing, has no constructor, but has pointer receivers. We can use `new()` to create an uninitialized `*ProductRepo`

```go
	// create our dependencies
	productRepo := new(storage.ProductRepo)
	productSvc := services.NewProductService(productRepo)
	deps := handler.Dependencies{
		Product: productSvc,
	}

	// create a handler and server
	app := handler.New(logger, deps)
```

### handler/product.go

We only have one route for now, but we're pretty sure we'll have many product-related routes. 
So let's create a seperate file for it.

Take your `homePage` function and copy it over, we're going to rename it `products` and add 'product fetching'.

```go
package handler

import (
	"html/template"
	"net/http"

	app "github.com/gerbenjacobs/go-webshop-course"
	"github.com/julienschmidt/httprouter"
)

func (h *Handler) products(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.logger.DebugContext(r.Context(), "Request received",
		"method", r.Method,
		"url", r.RequestURI,
	)
	tmpl := template.Must(template.ParseFiles(
		"static/layout.html",
		"static/homepage.html",
	))

	type pageData struct {
		User     bool
		Products []app.Product
	}

	// fetch our products
	products, err := h.Product.ListProducts(r.Context())
	if err != nil {
		h.logger.Error("failed to fetch products", "error", err)
		http.Error(w, "failed to fetch products", http.StatusInternalServerError)
		return
	}

	// render the templates
	if err := tmpl.Execute(w, pageData{false, products}); err != nil {
		h.logger.Error("failed to execute layout", "error", err)
		http.Error(w, "failed to create layout", http.StatusInternalServerError)
		return
	}
}
```

You might remember seeing `{{ if .User }}` in our templates, because of this, 
the data we send to `tmpl.Execute` needs to have a `User` as well.

So for now we've created an inline struct called `pageData`, but we should eventually 
move this to a better place.

The core functionality however is us adding `h.Product.ListProducts()`. 
Because we added our `Dependencies` anonymously, we can directly call our ProductService,
which we named `Product`. If you're not happy with these names, you can change them.

### static/homepage.html

Now that we're sending `Products` to our HTML, let's see if we can do something with it.

Replace our 'Lorem ipsum' paragaph with this.

```
        {{ if .Products }}
            <ul>
            {{ range .Products }}
                <li>{{ . }}</li>
            {{ end }}
            </ul>
        {{ else }}
            <p>No products.</p>
        {{ end }}
```

Let's check our page; what does it say? "No products"? That might be correct, huh!

### storage/product_repository_memory.go

Let's go back to your in-memory Product repo. Since we don't have a `CreateProduct()` method yet,
let's create a constructor and pre-fill our map with data.

```go
func NewProductRepo() *ProductRepo {

}
```

__Task__: That's the signature, now you complete the body.

At this point you also better have thought about what your specific shop is selling.
Is it books? Flowers? Gadgets? CDs or vinyl? Dark web items? Or maybe it's a digital coffee shop?

### cmd/app/main.go

Now that our repo has an actual constructor, and a useful one as well, since 
it's pre-populating our data, we should use it in main.

Find

```go
productRepo := new(storage.ProductRepo)
```

Replace

```go
productRepo := storage.NewProductRepo()
```

## Finalize

Stop your app if it's running and start it again with your latest changes to `main.go`.

```go
go run ./cmd/app/main.go
```

Does your page say something like this?

```
Webshop
{1 Gopher plushie A small purple Gophier plushie, perfect for kids and adults alike. 12.99}
{2 PHP Elephant plushie An elephant with the PHP logo, available in blue and pink 20}
```

Unless you have chosen to sell plushies, it might look different, but the format is the same.

The `html/template` is helping us out a little bit here, by rendering the entire `Product` struct,
and normally we would probably have better HTML and use the fields: `{{ .Name }} - €{{ .Price }}`.

There's a small fix we can do quickly though. Let's go to `product.go`, our domain model in root.

```go
func (p Product) String() string {
	return fmt.Sprintf("[%d] %s - %s (€%.2f)", p.ID, p.Name, p.Description, p.Price)
}
```

If we create a function (without pointer) and call it `String()` that returns just `string`,
we are implementing the [Stringer interface](https://pkg.go.dev/fmt#Stringer) and that's what used instead.

```
[1] Gopher plushie - A small purple Gophier plushie, perfect for kids and adults alike. (€12.99)
[2] PHP Elephant plushie - An elephant with the PHP logo, available in blue and pink (€20.00)
```

__Congratulations!__

Your webshop is showing products! Sort of..